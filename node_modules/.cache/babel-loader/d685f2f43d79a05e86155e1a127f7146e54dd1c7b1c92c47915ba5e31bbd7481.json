{"ast":null,"code":"import{useParams}from\"react-router-dom\";import Loader from\"../components/atoms/Loader\";import{useQuery}from\"react-query\";import{getProductById}from\"../services/api/product\";import ProductDetailTemplate from\"../components/templates/ProductDetailTemplate\";import ErrorTypo from\"../components/atoms/ErrorTypo\";import{jsx as _jsx}from\"react/jsx-runtime\";const ProductDetailPage=()=>{var _data$data;// const dispatch = useDispatch(); // react-query 사용으로 disable\n// useParams로 파라미터 가져오기 ex: ...URL/user/1에서 user는 pathname, 1은 parameter\nconst{id}=useParams();// 주의! useParams로 받은 값은 항상 string이다. 필요 시 가공하여 사용\n// const parsedId = parseInt(id, 10); // 10진수로 파싱 // 지금은 필요 없음 만약 다른 프로젝트에서 필요하다면 사용\n/* \n  아래의 세줄의 상태 관리 코드를 직후 코드처럼 한 줄로 사용하면 안되나? => 안된다\n  왜? 코드는 줄어들지 몰라도 이렇게 하면은 detail이 바뀌면 \n  다른 값들도 모두 리프레쉬 되며 렌더링되므로 성능 저하의 원인이 된다.\n  const {loading, error, detail} = useSelector((state) => state.detail); \n  */ /* 그러면 어떻게 해결할 수 있지? => useSWR 또는 react-query 사용하여 해결 */ // react-query 사용 이전 코드\n// const loading = useSelector((state) => state.detail.loading);\n// const error = useSelector((state) => state.detail.error);\n// const detail = useSelector((state) => state.detail.detail);\n// react-query를 이용한 상태 관리\nconst{data,error,isLoading}=useQuery(`product/${id}`,()=>getProductById(id));// 구분자, API 요청 함수\n// react-query 사용 이전 코드\n// useEffect(() => {\n//   dispatch(getDetail(id));\n// }, [dispatch, id]);\n// props drilling을 방지하기 위해 redux를 이용하거나 context api를 이용하여 관리하는 것이 좋다.(product)\nconst product=data===null||data===void 0?void 0:(_data$data=data.data)===null||_data$data===void 0?void 0:_data$data.response;// product에 우리가 원하는 데이터가 정확히 존재하는지 검증할 필요가 있다.\n// 1. Typescript로 interface, type 지정하여 이용\n// 2. 검증 함수: data가 정확이 들어왔는지 체크, validate function\nconst validate=()=>{if(!product){return false;}const requiredKeys=[\"id\",\"productName\"];const keys=Object.keys(product);// Object의 프로로타입 메소드인 keys를 이용하여 product의 Key들을 배열로 받음\nfor(let i=0;i<requiredKeys.length;i++){const requiredKey=requiredKeys[i];if(!keys.includes(requiredKey)){alert(`product 객체에 ${requiredKeys}가 존재하지 않습니다.`);return false;}}return true;};if(isLoading)return/*#__PURE__*/_jsx(Loader,{});else if(error)return/*#__PURE__*/_jsx(ErrorTypo,{});else if(validate()===false)return/*#__PURE__*/_jsx(ErrorTypo,{});else return/*#__PURE__*/_jsx(ProductDetailTemplate,{product:product});};export default ProductDetailPage;","map":{"version":3,"names":["useParams","Loader","useQuery","getProductById","ProductDetailTemplate","ErrorTypo","jsx","_jsx","ProductDetailPage","_data$data","id","data","error","isLoading","product","response","validate","requiredKeys","keys","Object","i","length","requiredKey","includes","alert"],"sources":["/Users/master/Desktop/coupon-project/kakaoshop-FE/src/pages/ProductDetailPage.jsx"],"sourcesContent":["import { useParams } from \"react-router-dom\";\nimport Loader from \"../components/atoms/Loader\";\nimport { useQuery } from \"react-query\";\nimport { getProductById } from \"../services/api/product\";\nimport ProductDetailTemplate from \"../components/templates/ProductDetailTemplate\";\nimport ErrorTypo from \"../components/atoms/ErrorTypo\";\n\nconst ProductDetailPage = () => {\n  // const dispatch = useDispatch(); // react-query 사용으로 disable\n  // useParams로 파라미터 가져오기 ex: ...URL/user/1에서 user는 pathname, 1은 parameter\n  const { id } = useParams(); // 주의! useParams로 받은 값은 항상 string이다. 필요 시 가공하여 사용\n  // const parsedId = parseInt(id, 10); // 10진수로 파싱 // 지금은 필요 없음 만약 다른 프로젝트에서 필요하다면 사용\n\n  /* \n  아래의 세줄의 상태 관리 코드를 직후 코드처럼 한 줄로 사용하면 안되나? => 안된다\n  왜? 코드는 줄어들지 몰라도 이렇게 하면은 detail이 바뀌면 \n  다른 값들도 모두 리프레쉬 되며 렌더링되므로 성능 저하의 원인이 된다.\n  const {loading, error, detail} = useSelector((state) => state.detail); \n  */\n  /* 그러면 어떻게 해결할 수 있지? => useSWR 또는 react-query 사용하여 해결 */\n  // react-query 사용 이전 코드\n  // const loading = useSelector((state) => state.detail.loading);\n  // const error = useSelector((state) => state.detail.error);\n  // const detail = useSelector((state) => state.detail.detail);\n\n  // react-query를 이용한 상태 관리\n  const { data, error, isLoading } = useQuery(`product/${id}`, () =>\n    getProductById(id)\n  ); // 구분자, API 요청 함수\n\n  // react-query 사용 이전 코드\n  // useEffect(() => {\n  //   dispatch(getDetail(id));\n  // }, [dispatch, id]);\n\n  // props drilling을 방지하기 위해 redux를 이용하거나 context api를 이용하여 관리하는 것이 좋다.(product)\n\n  const product = data?.data?.response;\n  // product에 우리가 원하는 데이터가 정확히 존재하는지 검증할 필요가 있다.\n  // 1. Typescript로 interface, type 지정하여 이용\n  // 2. 검증 함수: data가 정확이 들어왔는지 체크, validate function\n\n  const validate = () => {\n    if (!product) {\n      return false;\n    }\n    const requiredKeys = [\"id\", \"productName\"];\n    const keys = Object.keys(product); // Object의 프로로타입 메소드인 keys를 이용하여 product의 Key들을 배열로 받음\n    for (let i = 0; i < requiredKeys.length; i++) {\n      const requiredKey = requiredKeys[i];\n      if (!keys.includes(requiredKey)) {\n        alert(`product 객체에 ${requiredKeys}가 존재하지 않습니다.`);\n        return false;\n      }\n    }\n    return true;\n  };\n\n  if (isLoading) return <Loader />;\n  else if (error) return <ErrorTypo />;\n  else if (validate() === false) return <ErrorTypo />;\n  else return <ProductDetailTemplate product={product} />;\n};\n\nexport default ProductDetailPage;\n"],"mappings":"AAAA,OAASA,SAAS,KAAQ,kBAAkB,CAC5C,MAAO,CAAAC,MAAM,KAAM,4BAA4B,CAC/C,OAASC,QAAQ,KAAQ,aAAa,CACtC,OAASC,cAAc,KAAQ,yBAAyB,CACxD,MAAO,CAAAC,qBAAqB,KAAM,+CAA+C,CACjF,MAAO,CAAAC,SAAS,KAAM,+BAA+B,CAAC,OAAAC,GAAA,IAAAC,IAAA,yBAEtD,KAAM,CAAAC,iBAAiB,CAAGA,CAAA,GAAM,KAAAC,UAAA,CAC9B;AACA;AACA,KAAM,CAAEC,EAAG,CAAC,CAAGV,SAAS,CAAC,CAAC,CAAE;AAC5B;AAEA;AACF;AACA;AACA;AACA;AACA,IALE,CAMA,yDACA;AACA;AACA;AACA;AAEA;AACA,KAAM,CAAEW,IAAI,CAAEC,KAAK,CAAEC,SAAU,CAAC,CAAGX,QAAQ,CAAC,WAAWQ,EAAE,EAAE,CAAE,IAC3DP,cAAc,CAACO,EAAE,CACnB,CAAC,CAAE;AAEH;AACA;AACA;AACA;AAEA;AAEA,KAAM,CAAAI,OAAO,CAAGH,IAAI,SAAJA,IAAI,kBAAAF,UAAA,CAAJE,IAAI,CAAEA,IAAI,UAAAF,UAAA,iBAAVA,UAAA,CAAYM,QAAQ,CACpC;AACA;AACA;AAEA,KAAM,CAAAC,QAAQ,CAAGA,CAAA,GAAM,CACrB,GAAI,CAACF,OAAO,CAAE,CACZ,MAAO,MAAK,CACd,CACA,KAAM,CAAAG,YAAY,CAAG,CAAC,IAAI,CAAE,aAAa,CAAC,CAC1C,KAAM,CAAAC,IAAI,CAAGC,MAAM,CAACD,IAAI,CAACJ,OAAO,CAAC,CAAE;AACnC,IAAK,GAAI,CAAAM,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGH,YAAY,CAACI,MAAM,CAAED,CAAC,EAAE,CAAE,CAC5C,KAAM,CAAAE,WAAW,CAAGL,YAAY,CAACG,CAAC,CAAC,CACnC,GAAI,CAACF,IAAI,CAACK,QAAQ,CAACD,WAAW,CAAC,CAAE,CAC/BE,KAAK,CAAC,eAAeP,YAAY,cAAc,CAAC,CAChD,MAAO,MAAK,CACd,CACF,CACA,MAAO,KAAI,CACb,CAAC,CAED,GAAIJ,SAAS,CAAE,mBAAON,IAAA,CAACN,MAAM,GAAE,CAAC,CAAC,IAC5B,IAAIW,KAAK,CAAE,mBAAOL,IAAA,CAACF,SAAS,GAAE,CAAC,CAAC,IAChC,IAAIW,QAAQ,CAAC,CAAC,GAAK,KAAK,CAAE,mBAAOT,IAAA,CAACF,SAAS,GAAE,CAAC,CAAC,IAC/C,oBAAOE,IAAA,CAACH,qBAAqB,EAACU,OAAO,CAAEA,OAAQ,CAAE,CAAC,CACzD,CAAC,CAED,cAAe,CAAAN,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}